static int dissect_coap_options_main ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * coap_tree , gint offset , guint8 opt_count , guint * opt_num , gint offset_end , coap_info * coinfo , coap_common_dissect_t * dissect_hf ) {
 guint8 opt_jump ;
 gint opt_length , opt_length_ext , opt_delta , opt_delta_ext ;
 gint opt_length_ext_off = 0 ;
 gint8 opt_length_ext_len = 0 ;
 gint opt_delta_ext_off = 0 ;
 gint8 opt_delta_ext_len = 0 ;
 gint orig_offset = offset ;
 proto_tree * subtree ;
 proto_item * item ;
 char strbuf [ 56 ] ;
 opt_jump = tvb_get_guint8 ( tvb , offset ) ;
 if ( 0xff == opt_jump ) return offset ;
 offset += 1 ;
 switch ( opt_jump & 0xf0 ) {
 case 0xd0 : opt_delta_ext = tvb_get_guint8 ( tvb , offset ) ;
 opt_delta_ext_off = offset ;
 opt_delta_ext_len = 1 ;
 offset += 1 ;
 opt_delta = 13 ;
 opt_delta += opt_delta_ext ;
 break ;
 case 0xe0 : opt_delta_ext = coap_get_opt_uint ( tvb , offset , 2 ) ;
 opt_delta_ext_off = offset ;
 opt_delta_ext_len = 2 ;
 offset += 2 ;
 opt_delta = 269 ;
 opt_delta += opt_delta_ext ;
 break ;
 case 0xf0 : expert_add_info_format ( pinfo , coap_tree , & dissect_hf -> ei . opt_length_bad , "end-of-options marker found, but option length isn't 15" ) ;
 return - 1 ;
 default : opt_delta = ( ( opt_jump & 0xf0 ) >> 4 ) ;
 break ;
 }
 * opt_num += opt_delta ;
 switch ( opt_jump & 0x0f ) {
 case 0x0d : opt_length_ext = tvb_get_guint8 ( tvb , offset ) ;
 opt_length_ext_off = offset ;
 opt_length_ext_len = 1 ;
 offset += 1 ;
 opt_length = 13 ;
 opt_length += opt_length_ext ;
 break ;
 case 0x0e : opt_length_ext = coap_get_opt_uint ( tvb , offset , 2 ) ;
 opt_length_ext_off = offset ;
 opt_length_ext_len = 2 ;
 offset += 2 ;
 opt_length = 269 ;
 opt_length += opt_length_ext ;
 break ;
 case 0x0f : expert_add_info_format ( pinfo , coap_tree , & dissect_hf -> ei . opt_length_bad , "end-of-options marker found, but option delta isn't 15" ) ;
 return - 1 ;
 default : opt_length = ( opt_jump & 0x0f ) ;
 break ;
 }
 if ( opt_length > offset_end - offset ) {
 expert_add_info_format ( pinfo , coap_tree , & dissect_hf -> ei . opt_length_bad , "option longer than the package" ) ;
 return - 1 ;
 }
 coap_opt_check ( pinfo , coap_tree , * opt_num , opt_length , dissect_hf ) ;
 g_snprintf ( strbuf , sizeof ( strbuf ) , "#%u: %s" , opt_count , val_to_str_const ( * opt_num , vals_opt_type , * opt_num % 14 == 0 ? "No-Op" : "Unknown Option" ) ) ;
 item = proto_tree_add_string ( coap_tree , dissect_hf -> hf . opt_name , tvb , orig_offset , offset - orig_offset + opt_length , strbuf ) ;
 subtree = proto_item_add_subtree ( item , dissect_hf -> ett . option ) ;
 g_snprintf ( strbuf , sizeof ( strbuf ) , "Type %u, %s, %s%s" , * opt_num , ( * opt_num & 1 ) ? "Critical" : "Elective" , ( * opt_num & 2 ) ? "Unsafe" : "Safe" , ( ( * opt_num & 0x1e ) == 0x1c ) ? ", NoCacheKey" : "" ) ;
 proto_tree_add_string ( subtree , dissect_hf -> hf . opt_desc , tvb , orig_offset , offset - orig_offset + opt_length , strbuf ) ;
 proto_tree_add_item ( subtree , dissect_hf -> hf . opt_delta , tvb , orig_offset , 1 , ENC_BIG_ENDIAN ) ;
 proto_tree_add_item ( subtree , dissect_hf -> hf . opt_length , tvb , orig_offset , 1 , ENC_BIG_ENDIAN ) ;
 if ( opt_delta_ext_off && opt_delta_ext_len ) proto_tree_add_item ( subtree , dissect_hf -> hf . opt_delta_ext , tvb , opt_delta_ext_off , opt_delta_ext_len , ENC_BIG_ENDIAN ) ;
 if ( opt_length_ext_off && opt_length_ext_len ) proto_tree_add_item ( subtree , dissect_hf -> hf . opt_length_ext , tvb , opt_length_ext_off , opt_length_ext_len , ENC_BIG_ENDIAN ) ;
 switch ( * opt_num ) {
 case COAP_OPT_CONTENT_TYPE : dissect_coap_opt_ctype ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_ctype , coinfo ) ;
 break ;
 case COAP_OPT_MAX_AGE : dissect_coap_opt_uint ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_max_age ) ;
 break ;
 case COAP_OPT_PROXY_URI : dissect_coap_opt_proxy_uri ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_proxy_uri ) ;
 break ;
 case COAP_OPT_PROXY_SCHEME : dissect_coap_opt_proxy_scheme ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_proxy_scheme ) ;
 break ;
 case COAP_OPT_SIZE1 : dissect_coap_opt_uint ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_size1 ) ;
 break ;
 case COAP_OPT_ETAG : dissect_coap_opt_hex_string ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_etag ) ;
 break ;
 case COAP_OPT_URI_HOST : dissect_coap_opt_uri_host ( tvb , item , subtree , offset , opt_length , coinfo , dissect_hf -> hf . opt_uri_host ) ;
 break ;
 case COAP_OPT_LOCATION_PATH : dissect_coap_opt_location_path ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_location_path ) ;
 break ;
 case COAP_OPT_URI_PORT : dissect_coap_opt_uri_port ( tvb , item , subtree , offset , opt_length , coinfo , dissect_hf -> hf . opt_uri_port ) ;
 break ;
 case COAP_OPT_LOCATION_QUERY : dissect_coap_opt_location_query ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_location_query ) ;
 break ;
 case COAP_OPT_OBJECT_SECURITY : dissect_coap_opt_object_security ( tvb , item , subtree , offset , opt_length , pinfo , coinfo , dissect_hf ) ;
 break ;
 case COAP_OPT_URI_PATH : dissect_coap_opt_uri_path ( tvb , item , subtree , offset , opt_length , coinfo , dissect_hf -> hf . opt_uri_path ) ;
 break ;
 case COAP_OPT_OBSERVE : dissect_coap_opt_uint ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_observe ) ;
 break ;
 case COAP_OPT_ACCEPT : dissect_coap_opt_ctype ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_accept , coinfo ) ;
 break ;
 case COAP_OPT_IF_MATCH : dissect_coap_opt_hex_string ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_if_match ) ;
 break ;
 case COAP_OPT_URI_QUERY : dissect_coap_opt_uri_query ( tvb , item , subtree , offset , opt_length , coinfo , dissect_hf -> hf . opt_uri_query ) ;
 break ;
 case COAP_OPT_BLOCK2 : dissect_coap_opt_block ( tvb , item , subtree , offset , opt_length , coinfo , dissect_hf ) ;
 break ;
 case COAP_OPT_BLOCK1 : dissect_coap_opt_block ( tvb , item , subtree , offset , opt_length , coinfo , dissect_hf ) ;
 break ;
 case COAP_OPT_IF_NONE_MATCH : break ;
 case COAP_OPT_BLOCK_SIZE : dissect_coap_opt_uint ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_block_size ) ;
 break ;
 default : dissect_coap_opt_hex_string ( tvb , item , subtree , offset , opt_length , dissect_hf -> hf . opt_unknown ) ;
 break ;
 }
 return offset + opt_length ;
 }